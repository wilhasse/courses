package main

import (
	"fmt"

	ast "github.com/dolthub/vitess/go/vt/sqlparser"
)

func main() {
	sql := "SELECT (SELECT SUM(P2.TOTAL) AS TOTAL_PARC FROM (PARCELA P2) WHERE P2.ID_ACORDO = P.ID_ACORDO AND P2.VENCIMENTO = MIN(P.VENCIMENTO) GROUP BY P2.ID_ACORDO) AS TOTAL_PARC,(SELECT COUNT(DISTINCT P4.VENCIMENTO) AS QTD_PARC FROM (PARCELA P4) WHERE P4.ID_ACORDO = P.ID_ACORDO GROUP BY P4.ID_ACORDO) AS QTD_PARC,C.ID_CARTEIRA,A.ID_ACORDO,C.FASE,(TO_DAYS(MIN(P.VENCIMENTO))-TO_DAYS(MIN(P.VENC_ORIGINAL))) AS ATRASO,GROUP_CONCAT(DATE_FORMAT(P.VENC_ORIGINAL,'')) AS VENC_ORIGINAL,C.NOME,C.NUM_CONTRATO,C.CPF,A.NUM_PARCELAS,A.TOTAL,SUM(P.HONORARIOS) AS HO ,A.DATA,A.DATA AS DATA_HORA,A.DATA AS HORA,A.DATA_REVERTE,A.DT_GRAVACAO,A.VENC_PARC_ABERTO,MIN(P.VENCIMENTO) AS VENCIMENTO,MIN(P.VENC_ORIGINAL) AS VENC_ORIG_PRIM_PARC_AC,TO_DAYS(A.DATA) - TO_DAYS(MIN(P.VENC_ORIGINAL)) AS ATRASO_GRAVACAO,C.ID_FUNCIONARIO,D.CONTRATO,G.ACORDO_FP,F.LOGIN,A.ID_ACORDO,C.PRINCIPAL,I.ACORDO_STATUS,FI.NOME AS FILIAL,F.NOME AS NOME_FUNC,(SELECT E.EMAIL FROM (EMAIL E) WHERE E.CPF = C.CPF AND E.STATUS = '0' ORDER BY E.STATUS,E.ULTIMA_ATUALIZ DESC LIMIT 1) AS EMAIL,ED.ESTADO AS UF,(CASE WHEN ED.ESTADO IN ('PR','RS','SC') THEN 'Sul' WHEN ED.ESTADO IN ('SP','RJ','ES','MG') THEN 'Sudeste' WHEN ED.ESTADO IN ('MT','MS','GO') THEN 'Centro-Oeste' WHEN ED.ESTADO IN ('BA','AL','SE','PB','PE','RN','CE','PI','MA') THEN 'Nordeste' WHEN ED.ESTADO IN ('AM','RR','AP','PA','TO','RO','AC') THEN 'Norte' ELSE 'N/D' END) AS REGIAO,IF(TIME(A.`DATA`) > TUR.HORA_FIM,'Vespertino','Matutino')AS 'TURNO',T.ID_EMPRESA,H.STATUS_JUR,FI.NOME AS FILIAL,IF(P.NUM_PARC = 0, 'SIM', 'NÃO') AS REFIN,A.NOME_CAMPANHA,A.FASE AS FASE_ACORDO,CO.ACORDO_TIPO_ACORDO,C1.ACORDO_TIPO AS TIPO_ACORDO_DESC,C.SCORE_INTERNO,CLT.SCORE AS SERASA,C.SCORE,A.TOTAL AS TOTAL_ACORDO,A.TIPO_ACORDO,T.NOME AS NOME_CARTEIRA_CONTR,T2.NOME AS NOME_CARTEIRA_ACORDO,SUM(P.COMISSAO_EMPR) AS COMISSAO,SUM(P.REPASSE) AS REPASSE,F1.LOGIN AS LOGIN_APROVACAO_AC,MIN(P.NUM_PARC) AS NUM_PARC,C.ID_CONTR,C.ULT_DT_COB AS DEFASAGEM,V.HISTORICO AS ULT_HIST_COB,C.DATA_IMPORTACAO,A.NUM_PARC_ABERTO,FRS.LOGIN AS FUNC_REQUER_SENHA,LRS.DATA AS DATA_REQUER_SENHA,CDAIC.MODO_COBRANCA AS MODO_ACORDO,CDAIC.MODO_COBRANCA AS MODO_ACORDO_02,C.ULT_DT_COB,V1.HISTORICO AS ULT_HIST,(SUM(P.PRINCIPAL_C) - SUM(P.PRINCIPAL)) AS DESC_PRINC,(SUM(P.MULTA_C) - SUM(P.MULTA)) AS DESC_MULTA,(SUM(P.JUROS_C) - SUM(P.JUROS)) AS DESC_JUR,(SUM(P.PRINCIPAL_C + P.MULTA_C + P.JUROS_C + P.CORRECAO_C +     P.HONORARIOS_C + P.NOTIFICACAO_C)) AS VLR_SEM_DESC,(SUM((P.PRINCIPAL_C + P.MULTA_C + P.JUROS_C + P.CORRECAO_C +      P.HONORARIOS_C + P.NOTIFICACAO_C)-     (P.PRINCIPAL_O + P.MULTA_O + P.JUROS_O + P.CORRECAO_O +      P.HONORARIOS_O + P.NOTIFICACAO_O))) AS VLR_DESC,IF(ACP.ID_ACORDO IS NOT NULL, 'Sim', 'Não') AS GRAVADO_CARTAO,SUM(P.PRINCIPAL_C) AS PRINCIPAL_C,IF(C.PESSOA_JURIDICA=1,'PJ','PF') AS PESSOA,C.SCORE,IBCL.NOME_CLUSTER AS ITAU_BANCO_CLUSTER,COD_2.CONTR_ITAU_BANCO_PROP_OFERTA,CIB.FX_RENDA_RESULT,ICL.RENDA AS RENDA_ELEITA_BR,C.DATA_NASC,IF(ICL.CORRENTISTA = 1,'Sim',IF(ICL.CORRENTISTA = 2,'Ex','Não')) AS CORREN,ICL.PROPENSAO AS AVAP,ICL.PRIORIDADE,AIB.TIPO_CAMP,A.NUM_PARC_ABERTO,CLR.DESCRICAO AS AGRUPAMENTO_DE_CLUSTER,IF(CIB.NOVO_SEGMENTO = 1,'Sim', '') AS NOVO_SEGMENTO,IF(ICL.PHYGITAL = 1, 'Sim', 'Não') AS PHYGITAL,AIB.ID_ACORDO_ITAU_API,(SELECT GROUP_CONCAT(PGA.NUM_CONTRATO) AS NUM_CONTR_MOV FROM (PARC_GERAL_ACORDO PGA) WHERE C.ID_CONTR = PGA.ID_CONTR AND A.ID_ACORDO = PGA.ID_ACORDO GROUP BY A.ID_ACORDO, P.NUM_PARC) AS NUM_CONTR_MOV,(SELECT GROUP_CONCAT(DISTINCT IBCM.NOME) AS CLUSTER_MOVIMENTO FROM (PARC_GERAL_ITAU_BANCO PGI,PARC_GERAL PG,PARC_GERAL_ACORDO PGA2,ITAU_BANCO_CLUSTER_MOVIMENTO IBCM) WHERE C.ID_CONTR = PGA2.ID_CONTR AND A.ID_ACORDO = PGA2.ID_ACORDO AND PG.ID_CONTR = PGA2.ID_CONTR AND PG.NUM_PARC = PGA2.NUM_PARC AND PG.NUM_CONTRATO = PGA2.NUM_CONTRATO AND PGI.COD_CLUSTER = IBCM.COD_CLUSTER AND PG.ID_CONTR = C.ID_CONTR AND PG.ID_CONTR = PGI.ID_CONTR AND PG.NUM_CONTRATO = PGI.NUM_CONTRATO AND PG.NUM_PARC = PGI.NUM_PARC AND PG.STATUS IN (0,1,3) GROUP BY PG.ID_CONTR) AS CLUSTER_MOVIMENTO,(SELECT SUM(PGI.VALOR_CONTABIL) FROM (PARC_GERAL_ITAU_BANCO PGI,PARC_GERAL PG,PARC_GERAL_ACORDO PGA2) WHERE C.ID_CONTR = PGA2.ID_CONTR AND A.ID_ACORDO = PGA2.ID_ACORDO AND PG.ID_CONTR = PGA2.ID_CONTR AND PG.NUM_PARC = PGA2.NUM_PARC AND PG.NUM_CONTRATO = PGA2.NUM_CONTRATO AND PG.ID_CONTR = C.ID_CONTR AND PG.ID_CONTR = PGI.ID_CONTR AND PG.NUM_CONTRATO = PGI.NUM_CONTRATO AND PG.NUM_PARC = PGI.NUM_PARC) AS VALOR_CONTABIL,(SELECT GROUP_CONCAT(DISTINCT IBCM.NOME) AS CLUSTER_META FROM (PARC_GERAL_ITAU_BANCO PGI,PARC_GERAL PG,PARC_GERAL_ACORDO PGA2,ITAU_BANCO_CLUSTER_MOVIMENTO IBCM) WHERE C.ID_CONTR = PGA2.ID_CONTR AND A.ID_ACORDO = PGA2.ID_ACORDO AND PG.ID_CONTR = PGA2.ID_CONTR AND PG.NUM_PARC = PGA2.NUM_PARC AND PG.NUM_CONTRATO = PGA2.NUM_CONTRATO AND PGI.COD_CLUSTER_META = IBCM.COD_CLUSTER AND PG.ID_CONTR = C.ID_CONTR AND PG.ID_CONTR = PGI.ID_CONTR AND PG.NUM_CONTRATO = PGI.NUM_CONTRATO AND PG.NUM_PARC = PGI.NUM_PARC AND PG.STATUS IN (0,1,3) GROUP BY PG.ID_CONTR) AS CLUSTER_META,(SELECT GROUP_CONCAT(DISTINCT PGI.RADAR) AS RADAR FROM (PARC_GERAL_ITAU_BANCO PGI,PARC_GERAL PG) WHERE PG.ID_CONTR = C.ID_CONTR AND PG.ID_CONTR = PGI.ID_CONTR AND PG.NUM_CONTRATO = PGI.NUM_CONTRATO AND PG.NUM_PARC = PGI.NUM_PARC AND PG.STATUS IN (0,1,3)) AS RADAR,AIB.ALCADA,IF(AE3.ID_ACORDO IS NULL, 'NÃO','SIM') AS EXCECAO,AIB.LEILAO,AIB.LEILAO_PESO,IFNULL((SELECT 'Nao' AS SEM_FC_EMITIDA FROM (ACORDO A2,FC F2,FC_IDENT FI2,BOLETO_GERADO BG2) WHERE A2.ID_ACORDO = A.ID_ACORDO AND A2.ID_CONTR = F2.ID_CONTR AND  NOT  isNULL(F2.COD_BARRAS)  AND FI2.ID_ACORDO = A2.ID_ACORDO AND F2.GERADO <> '0' AND BG2.ID_FC = F2.ID_FC AND F2.ID_FC = FI2.ID_FC ORDER BY F2.DATA_EMISSAO DESC LIMIT 1), 'Sim') AS SEM_FC_EMITIDA,IFNULL((SELECT 'Nao' AS SEM_FC_VALIDA FROM (ACORDO A3,FC F3,FC_IDENT FI3,BOLETO_GERADO BG3) WHERE A3.ID_ACORDO = A.ID_ACORDO AND A3.ID_CONTR = F3.ID_CONTR AND  NOT  isNULL(F3.COD_BARRAS)  AND FI3.ID_ACORDO = A3.ID_ACORDO AND F3.GERADO <> '0' AND BG3.ID_FC = F3.ID_FC AND A3.STATUS IN (0,1,2) AND F3.VENC >= '2024-05-10' AND F3.ID_FC = FI3.ID_FC ORDER BY F3.DATA_EMISSAO DESC LIMIT 1), 'Sim') AS SEM_FC_VALIDA FROM ((ITAU_BANCO_CLUSTER IBCL,CODIGO COD_2,CONTR_ITAU_BANCO CIB,ACORDO_ITAU_BANCO AIB,ITAU_BANCO_AGRUP_CLUSTER CLR,CONTRATO C,CARTEIRA T,CARTEIRA T2,ACORDO A,CODIGO D,CODIGO G,CODIGO I,PARCELA P,FUNCIONARIO F,FILIAL FI,CODIGO H,CODIGO CO,CODIGO C1,CODIGO V,CODIGO V1,ENDERECO ED) LEFT JOIN TURNO TUR ON (TUR.ID_TURNO = '2') LEFT JOIN ITAU_CLIENTE ICL ON (ICL.CPF = C.CPF) LEFT JOIN ACORDO_EXCECAO AE3 ON (AE3.ID_ACORDO = A.ID_ACORDO) LEFT JOIN (CLASSIFICACAO_CPF CLA, CLASSIFICACAO CLT) ON (CLT.ID_CLASSIFICACAO_ORIGEM = '0' AND CLA.ID_CLASSIFICACAO = CLT.ID_CLASSIFICACAO AND CLA.CPF = C.CPF) LEFT JOIN (ACORDO_EXCECAO AE, FUNCIONARIO F1) ON (AE.ID_ACORDO = A.ID_ACORDO AND AE.ID_FUNC_APROVACAO = F1.ID_FUNCIONARIO) LEFT JOIN (LOG_REQUER_SENHA LRS, FUNCIONARIO FRS) ON (LRS.ID_ACORDO = A.ID_ACORDO AND LRS.ID_FUNCIONARIO = FRS.ID_FUNCIONARIO) LEFT JOIN (ACORDO_INFO_COMPL AIC, CODIGO CDAIC) ON (AIC.ID_ACORDO = A.ID_ACORDO AND AIC.MODO = CDAIC.COD) LEFT JOIN ACORDO_CARTAO_PGTO ACP ON (ACP.ID_ACORDO = A.ID_ACORDO)) WHERE C.ID_CARTEIRA = T.ID_CARTEIRA AND C.STATUS = D.COD AND A.STATUS = I.COD AND A.ID_CONTR = C.ID_CONTR AND A.FP_PARC_PROX = G.COD AND A.ID_ACORDO = P.ID_ACORDO AND A.ID_FUNCIONARIO = F.ID_FUNCIONARIO AND C.ID_FILIAL = FI.ID_FILIAL AND A.TIPO_ACORDO = CO.COD AND C.ULT_HIST_COB = V.COD AND C.ID_CARTEIRA IN  (0001) AND A.TIPO <> '0' AND A.STATUS IN  (0,4) AND P.VENCIMENTO >= '2023-11-01' AND P.VENCIMENTO < '2024-05-11' AND H.COD = C.STATUS_JUR AND A.ID_CARTEIRA = T2.ID_CARTEIRA AND C.ULT_HIST = V1.COD AND ED.ID_END = C.ID_END AND A.TIPO = C1.COD AND C.ID_CONTR = CIB.ID_CONTR AND CIB.COD_CLUSTER = IBCL.CODIGO_CLUSTER AND CIB.PROPENSAO_OFERTA = COD_2.COD AND A.ID_ACORDO = AIB.ID_ACORDO AND CIB.COD_AGRUP_CLUSTER = CLR.COD_AGRUP_CLUSTER GROUP BY C.ID_CONTR,A.ID_ACORDO ORDER BY C.ID_CARTEIRA,C.NOME,C.NUM_CONTRATO" // Your SQL query here

	// Parse the SQL into an AST
	stmt, err := ast.Parse(sql)
	if err != nil {
		fmt.Printf("Error parsing SQL: %v\n", err)
		return
	}

	// Type assert to a Select statement
	selectStmt, ok := stmt.(*ast.Select)
	if !ok {
		fmt.Println("Not a SELECT statement.")
		return
	}

	// Initialize a slice for the subqueries
	var subqueries []string

	// Traverse the AST
	ast.Walk(func(node ast.SQLNode) (kontinue bool, err error) {
		switch node := node.(type) {
		case *ast.Subquery:
			// Serialize the subquery to SQL and append to the slice
			subqueries = append(subqueries, ast.String(node))
		}
		return true, nil
	}, selectStmt)

	// Serialize the main query
	mainQuerySQL := ast.String(selectStmt)

	// Print the results
	fmt.Println("Main Query:", mainQuerySQL)
	fmt.Println("Subqueries:")
	for i, subquery := range subqueries {
		fmt.Printf("Subquery %d: %s\n", i+1, subquery)
	}
}
